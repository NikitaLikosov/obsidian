# Проект с вводом/выводом (I/O): создание консольного приложения

В этой главе вы примените многие знания, полученные ранее, а также познакомитесь с ещё неизученными API стандартной библиотеки. Мы создадим консольное приложение, которое будет взаимодействовать с файлом и с консольным вводом / выводом, чтобы попрактиковаться в некоторых концепциях Rust, с которыми вы уже знакомы.

Скорость, безопасность, компиляция в один исполняемый файл и кроссплатформенность делают Rust идеальным языком для создания консольных инструментов, так что в нашем проекте мы создадим свою собственную версию классической утилиты поиска `grep`, что расшифровывается, как "глобальное средство поиска и печати" (**g**lobally search a **r**egular **e**xpression and **p**rint). В простейшем случае `grep` используется для поиска в выбранном файле указанного текста. Для этого утилита `grep` получает имя файла и текст в качестве аргументов. Далее она читает файл, находит и выводит строки, содержащие искомый текст.

Попутно мы покажем, как сделать так, чтобы наше консольное приложение использовало возможности терминала, которые используются многими другими консольными инструментами. Мы будем читать значение переменной окружения, чтобы позволить пользователю настроить поведение нашего инструмента. Мы также будем печатать сообщения об ошибках в стандартный консольный поток ошибок ( `stderr` ) вместо стандартного вывода ( `stdout` ), чтобы, к примеру, пользователь мог перенаправить успешный вывод в файл, в то время, как сообщения об ошибках останутся на экране.

Один из участников Rust-сообщества, Andrew Gallant, уже реализовал полнофункциональный, очень быстрый аналог программы `grep` и назвал его `ripgrep`. По сравнению с ним, наша версия будет довольно простой, но эта глава даст вам знания, которые нужны для понимания реальных проектов, таких как <code>ripgrep</code>.

Наш проект `grep` будет использовать ранее изученные концепции:

- Организация кода (используя то, что вы узнали о модулях в [ главе 7]<!--  -->)
- Использование векторов и строк (коллекции, [глава 8]<!--  -->)
- Обработка ошибок ([Глава 9]<!--  -->)
- Использование типажей и времени жизни там, где это необходимо ([глава 10]<!--  -->)
- Написание тестов ( [Глава 11]<!--  -->)

Мы также кратко представим замыкания, итераторы и объекты типажи, которые будут объяснены подробно в главах [13]<!--  --> и [17]<!--  -->.


[ главе 7]: ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
[глава 8]: ch08-00-common-collections.html
[Глава 9]: ch09-00-error-handling.html
[глава 10]: ch10-00-generics.html
[Глава 11]: ch11-00-testing.html
[13]: ch13-00-functional-features.html
[17]: ch17-00-oop.html