## Дополнение Б: Операторы и обозначения

Это дополнение содержит глоссарий синтаксиса Rust, включая операторы и другие обозначения, которые появляются сами по себе или в контексте путей, обобщений, типажей, макросов, атрибутов, комментариев, кортежей и скобок.

### Операторы

Таблица Б-1 содержит операторы языка Rust, пример появления оператора, короткое объяснение, возможность перегрузки оператора. Если оператор можно перегрузить, то показан типаж, с помощью которого его можно перегрузить.

<span class="caption">Таблица Б-1: Операторы</span>

Оператор | Пример | Объяснение | Перегружаемость
--- | --- | --- | ---
`!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Вызов макроса |
`!` | `!expr` | Побитовое или логическое отрицание | `Not`
`!=` | `expr != expr` | Сравнение "не равно" | `PartialEq`
`%` | `expr % expr` | Остаток от деления | `Rem`
`%=` | `var %= expr` | Остаток от деления и присваивание | `RemAssign`
`&` | `&expr`, `&mut expr` | Заимствование |
`&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Указывает что данный тип заимствуется |
`&` | `expr & expr` | Побитовое И | `BitAnd`
`&=` | `var &= expr` | Побитовое И и присваивание | `BitAndAssign`
`&&` | `expr && expr` | Логическое И |
`*` | `expr * expr` | Арифметическое умножение | `Mul`
`*=` | `var *= expr` | Арифметическое умножение и присваивание | `MulAssign`
`*` | `*expr` | Разыменование ссылки | `Deref`
`*` | `*const type`, `*mut type` | Указывает, что данный тип является сырым указателем |
`+` | `trait + trait`, `'a + trait` | Соединение ограничений типа |
`+` | `expr + expr` | Арифметическое сложение | `Add`
`+=` | `var += expr` | Арифметическое сложение и присваивание | `AddAssign`
`,` | `expr, expr` | Разделитель аргументов и элементов |
`-` | `- expr` | Арифметическое отрицание | `Neg`
`-` | `expr - expr` | Арифметическое вычитание | `Sub`
`-` | `var -= expr` | Арифметическое вычитание и присваивание | `SubAssign`
`->` | `fn(...) -> type`, <code>&amp;vert;...&amp;vert; -&gt; type</code> | ... |
`.` | `expr.ident` | Доступ к элементу |
`..` | `..`, `expr..`, `..expr`, `expr..expr` | Указывает на диапазон чисел, исключая правый | `PartialOrd`
`..=` | `..=expr`, `expr..=expr` | Указывает на диапазон чисел, включая правый | `PartialOrd`
`..` | `..expr` | Синтаксис обновления структуры |
`..` | `variant(x, ..)`, `struct_type { x, .. }` | Привязка «И все остальное» |
`...` | `expr...expr` | (Устарело, используйте новый синтаксис `..=`) Используется при определении инклюзивного диапазона |
`/` | `expr / expr` | Арифметическое деление | `Div`
`/=` | `var /= expr` | Арифметическое деление и присваивание | `DivAssign`
`:` | `pat: type`, `ident: type` | Ограничения типов |
`:` | `ident: expr` | Инициализация поля структуры |
`:` | `'a: loop {...}` | Метка цикла |
`;` | `expr;` | Признак конца инструкции и элемента |
`;` | `[...; len]` | Часть синтаксиса массива фиксированного размера |
`<<` | `expr << expr` | Битовый сдвиг влево | `Shl`
`<<=` | `var <<= expr` | Битовый сдвиг влево и присваивание | `ShlAssign`
`<` | `expr < expr` | Сравнение "меньше чем" | `PartialOrd`
`<=` | `expr <= expr` | Сравнение "меньше или равно" | `PartialOrd`
`=` | `var = expr`, `ident = type` | Присваивание/эквивалентность |
`==` | `expr == expr` | Сравнение "равно" | `PartialEq`
`=>` | `pat => expr` | Часть синтаксиса конструкции match |
`>` | `expr > expr` | Сравнение "больше чем" | `PartialOrd`
`>=` | `expr >= expr` | Сравнение "больше или равно" | `PartialOrd`
`>>` | `expr >> expr` | Битовый сдвиг вправо | `Shr`
`>>=` | `var >>= expr` | Битовый сдвиг вправо и присваивание | `ShrAssign`
`@` | `ident @ pat` | Pattern binding |
`^` | `expr ^ expr` | Побитовое исключающее ИЛИ | `BitXor`
`^=` | `var ^= expr` | Побитовое исключающее ИЛИ и присваивание | `BitXorAssign`
<code>&amp;vert;</code> | <code>pat &amp;vert; pat</code> | Альтернативные шаблоны |
<code>&amp;vert;</code> | <code>expr &amp;vert; expr</code> | Побитовое ИЛИ | `BitOr`
<code>&amp;vert;=</code> | <code>var &amp;vert;= expr</code> | Побитовое ИЛИ и присваивание | `BitOrAssign`
<code>&amp;vert;&amp;vert;</code> | <code>expr &amp;vert;&amp;vert; expr</code> | Короткое логическое ИЛИ |
`?` | `expr?` | Возврат ошибки |

### Обозначения не-операторы

Следующий список содержит все символы, которые не работают как операторы; то есть они не ведут себя как вызов функции или метода.

Таблица Б-2 показывает символы, которые появляются сами по себе и допустимы в различных местах.

<span class="caption">Таблица Б-2: Автономный синтаксис</span>

Обозначение | Объяснение
--- | ---
`'ident` | Именованное время жизни или метка цикла
`...u8`, `...i32`, `...f64`, `...usize`, etc. | Числовой литерал определённого типа
`"..."` | Строковый литерал
`r"..."`, `r#"..."#`, `r##"..."##`, etc. | Необработанный строковый литерал, в котором не обрабатываются escape-символы
`b"..."` | Строковый литерал байтов; создаёт массив байтов вместо строки
`br"..."`, `br#"..."#`, `br##"..."##`, etc. | Необработанный строковый байтовый литерал, комбинация необработанного и байтового литерала
`'...'` | Символьный литерал
`b'...'` | ASCII байтовый литерал
<code>&amp;vert;...&amp;vert; expr</code> | Замыкание
`!` | Всегда пустой тип для расходящихся функций
`_` | «Игнорируемое» связывание шаблонов; также используется для читабельности целочисленных литералов

Таблица Б-3 показывает обозначения которые появляются в контексте путей иерархии модулей

<span class="caption">Таблица Б-3. Синтаксис, связанный с путями</span>

Обозначение | Объяснение
--- | ---
`ident::ident` | Путь к пространству имён
`::path` | Путь относительно корня крейта (т. е. явный абсолютный путь)
`self::path` | Путь относительно текущего модуля (т. е. явный относительный путь).
`super::path` | Путь относительно родительского модуля текущего модуля
`type::ident`, `<type as trait>::ident` | Ассоциированные константы, функции и типы
`<type>::...` | Ассоциированный элемент для типа, который не может быть назван прямо (например `<&T>::...`, `<[T]>::...`, etc.)
`trait::method(...)` | Устранение неоднозначности вызова метода путём именования типажа, который определяет его
`type::method(...)` | Устранение неоднозначности путём вызова метода через имя типа, для которого он определён
`<type as trait>::method(...)` | Устранение неоднозначности вызова метода путём именования типажа и типа

Таблица Б-4 показывает обозначения которые появляются в контексте использования обобщённых типов параметров

<span class="caption">Таблица Б-4: Обобщения</span>

Обозначение | Объяснение
--- | ---
`path<...>` | Определяет параметры для обобщённых параметров в типе (e.g., `Vec<u8>`)
`path::<...>`, `method::<...>` | Определяет параметры для обобщённых параметров, функций, или методов в выражении. Часто называют turbofish (например `"42".parse::<i32>()`)
`fn ident<...> ...` | Определение обобщённой функции
`struct ident<...> ...` | Определение обобщённой структуры
`enum ident<...> ...` | Объявление обобщённого перечисления
`impl<...> ...` | Определение обобщённой реализации
`for<...> type` | Высокоуровневое связывание времени жизни
`type<ident=type>` | Обобщённый тип где один или более ассоциированных типов имеют определённое присваивание (например `Iterator<Item=T>`)

Таблица Б-5 показывает обозначения которые появляются в контексте использования обобщённых типов параметров с ограничениями типов

<span class="caption">Таблица Б-5: Ограничения типов</span>

Обозначение | Объяснение
--- | ---
`T: U` | Обобщённый параметр `T` ограничивается до типов которые реализуют типаж `U`
`T: 'a` | Обобщённый тип `T` должен существовать не меньше чем `'a` (то есть тип не может иметь ссылки с временем жизни меньше чем `'a`)
`T: 'static` | Обобщённый тип `T` не имеет заимствованных ссылок кроме имеющих время жизни `'static`
`'b: 'a` | Обобщённое время жизни `'b` должно быть не меньше чем `'a`
`T: ?Sized` | Позволяет обобщённым типам параметра иметь динамический размер
`'a + trait`, `trait + trait` | Соединение ограничений типов

Таблица Б-6 показывает обозначения, которые появляются в контексте вызова или определения макросов и указания атрибутов элемента.

<span class="caption">Таблица Б-6: Макросы и атрибуты</span>

Обозначение | Объяснение
--- | ---
`#[meta]` | Внешний атрибут
`#![meta]` | Внутренний атрибут
`$ident` | Подстановка в макросе
`$ident:kind` | Захват макроса
`$(…)…` | Повторение макроса
`ident!(...)`, `ident!{...}`, `ident![...]` | Вызов макроса

Таблица Б-7 показывает обозначения, которые создают комментарии.

<span class="caption">Таблица Б-7: Комментарии</span>

Обозначение | Объяснение
--- | ---
`//` | Однострочный комментарий
`//!` | Внутренний однострочный комментарий документации
`///` | Внешний однострочный комментарий документации
`/*...*/` | Многострочный комментарий
`/*!...*/` | Внутренний многострочный комментарий документации
`/**...*/` | Внешний многострочный комментарий документации

Таблица Б-8 показывает обозначения, которые появляются в контексте использования кортежей.

<span class="caption">Таблица Б-8: Кортежи</span>

Обозначение | Объяснение
--- | ---
`()` | Пустой кортеж, он же пустой тип. И литерал и тип.
`(expr)` | Выражение в скобках
`(expr,)` | Кортеж с одним элементом выражения
`(type,)` | Кортеж с одним элементом типа
`(expr, ...)` | Выражение кортежа
`(type, ...)` | Тип кортежа
`(type, ...)` | Выражение вызова функции; также используется для инициализации структур-кортежей и вариантов-кортежей перечисления
`expr.0`, `expr.1`, etc. | Взятие элемента по индексу в кортеже

Таблица Б-9 показывает контексты, в которых используются фигурные скобки.

<span class="caption">Таблица Б-9: Фигурные скобки</span>

Контекст | Объяснение
--- | ---
`{...}` | Выражение блока
`Type {...}` | `struct` литерал

Таблица Б-10 показывает контексты, в которых используются квадратные скобки.

<span class="caption">Таблица Б-10: Квадратные скобки</span>

Контекст | Объяснение
--- | ---
`[...]` | Литерал массива
`[expr; len]` | Литерал массива, содержащий `len` копий `expr`
`[type; len]` | Массив, содержащий `len` экземпляров типа `type`
`expr[expr]` | Взятие по индексу в коллекции. Возможна перегрузка (`Index`, `IndexMut`)
`expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Взятие среза коллекции по индексу, используется `Range`, `RangeFrom`, `RangeTo`, или `RangeFull` как "индекс"
