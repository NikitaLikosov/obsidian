## Улучшение нашего проекта с вводом/выводом

Вооружившись полученными знаниями об итераторах, мы можем улучшить реализацию работы с вводом/выводом в проекте главы 12, применяя итераторы для того, чтобы сделать некоторые места в коде более понятными и лаконичными. Давайте рассмотрим, как итераторы могут улучшить нашу реализацию функции `Config::build` и функции `search`.

### Удаляем `clone`, используем итератор

В листинге 12-6 мы добавили код, который принимает срез значений `String` и создаёт экземпляр структуры `Config` путём индексации среза и клонирования значений, позволяя структуре `Config` владеть этими значениями. В листинге 13-17 мы воспроизвели реализацию функции `Config::build`, как это было в листинге 12-23:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-23-reproduced/src/lib.rs:ch13}}
```

<span class="caption">Листинг 13-17: Репродукция функции <code>Config::build</code> из листинга 12-23</span>

Ранее мы говорили, что не стоит беспокоиться о неэффективных вызовах `clone`, потому что мы удалим их в будущем. Ну что же, время пришло!

Нам понадобился здесь `clone`, потому что в параметре `args` у нас срез с элементами `String`, но функция `build` не владеет `args`. Чтобы экземпляр `Config` владел значениями, нам пришлось клонировать их из `args` в переменные `query` и `file_path`.

Благодаря нашим новым знаниям об итераторах мы можем изменить функцию `build`, чтобы вместо заимствования среза она принимала в качестве аргумента итератор. Мы будем использовать функциональность итератора вместо кода, который проверяет длину среза и обращается по индексу к определённым значениям. Это позволит лучше понять, что делает функция `Config::build`, поскольку итератор будет обращаться к значениям.

Как только `Config::build` получит в своё распоряжение итератор и перестанет использовать операции индексирования с заимствованием, мы сможем переместить значения `String` из итератора в `Config` вместо того, чтобы вызывать `clone` и создавать новое выделение памяти.

#### Использование возвращённого итератора напрямую

Откройте файл *src/main.rs* проекта ввода-вывода, который должен выглядеть следующим образом:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-12-24-reproduced/src/main.rs:ch13}}
```

Сначала мы изменим начало функции `main`, которая была в листинге 12-24, на код в листинге 13-18, который теперь использует итератор. Это не будет компилироваться, пока мы не обновим `Config::build`.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-18/src/main.rs:here}}
```

<span class="caption">Листинг 13-18: Передача возвращаемого значения из <code>env::args</code> в <code>Config::build</code></span>

Функция `env::args` возвращает итератор! Вместо того чтобы собирать значения итератора в вектор и затем передавать срез в `Config::build`, теперь мы передаём владение итератором, возвращённым из `env::args` в `Config::build` напрямую.

Далее нам нужно обновить определение `Config::build`. В файле *src/lib.rs* вашего проекта ввода-вывода изменим сигнатуру `Config::build` так, чтобы она выглядела как в листинге 13-19. Это все ещё не скомпилируется, потому что нам нужно обновить тело функции.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-19/src/lib.rs:here}}
```

<span class="caption">Листинг 13-19: Обновление сигнатуры <code>Config::build</code> для определения итератора как ожидаемого параметра</span>

Документация стандартной библиотеки для функции `env::args` показывает, что тип возвращаемого ею итератора - `std::env::Args`, и этот тип реализует признак `Iterator` и возвращает значения `String`.

Мы обновили сигнатуру функции `Config::build`, чтобы параметр `args` имел универсальный тип ограниченный трейтом `impl Iterator<Item = String>` вместо `&[String]`. Такое использование синтаксиса `impl Trait`, который мы обсуждали в разделе [" Трейты как параметры"]<!-- ignore --> главы 10, означает, что `args` может быть любым типом, реализующим тип `Iterator` и возвращающим элементы `String`.

Поскольку мы владеем `args` и будем изменять `args` в процессе итерации над ним, мы можем добавить ключевое слово `mut` в спецификацию параметра `args`, чтобы сделать его изменяемым.

#### Использование методов типажа `Iterator` вместо индексов

Далее мы подправим содержимое `Config::build`. Поскольку `args` реализует признак `Iterator`, мы знаем, что можем вызвать у него метод `next`! В листинге 13-20 код из листинга 12-23 обновлён для использования метода `next`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-20/src/lib.rs:here}}
```

<span class="caption">Листинг 13-20: Изменяем тело <code>Config::build</code> так, чтобы использовать методы итератора</span>

Помните, что первое значение в возвращаемых данных `env::args` - это имя программы. Мы хотим проигнорировать его и перейти к следующему значению, поэтому сперва мы вызываем `next` и ничего не делаем с возвращаемым значением. Затем мы вызываем `next`, чтобы получить значение, которое мы хотим поместить в поле `query` в `Config`. Если `next` возвращает `Some`, мы используем `match` для извлечения значения. Если возвращается `None`, это означает, что было задано недостаточно аргументов, и мы досрочно возвращаем значение `Err`. То же самое мы делаем для значения `file_path`.

### Делаем код понятнее с помощью адаптеров итераторов

Мы также можем воспользоваться преимуществами итераторов в функции `search` в нашем проекте с операциями ввода-вывода, которая воспроизведена здесь в листинге 13-21 так же, как и в листинге 12-19:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:ch13}}
```

<span class="caption">Листинг 13-21: Реализация функции <code>search</code> из листинга 12-19</span>

Мы можем написать этот код в более сжатом виде, используя методы адаптера итератора. Это также позволит нам избежать наличия изменяемого временного вектора `results`. Функциональный стиль программирования предпочитает минимизировать количество изменяемого состояния, чтобы сделать код более понятным. Удаление изменяемого состояния может позволить в будущем сделать поиск параллельным, поскольку нам не придётся управлять одновременным доступом к вектору `results`. В листинге 13-22 показано это изменение:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-22/src/lib.rs:here}}
```

<span class="caption">Листинг 13-22: Использование методов адаптера итератора в реализации функции <code>search</code></span>

Напомним, что назначение функции `search` - вернуть все строки в `contents`, которые содержат `query`. Подобно примеру `filter` в листинге 13-16, этот код использует адаптер `filter`, чтобы сохранить только те строки, для которых `line.contains(query)` возвращает `true`. Затем мы собираем совпадающие строки в другой вектор с помощью `collect`. Так гораздо проще! Не стесняйтесь сделать такое же изменение для использования методов итератора в функции `search_case_insensitive`.

### Выбор между циклами или итераторами

Следующий логичный вопрос - какой стиль вы должны выбрать в своём коде и почему: оригинальную реализацию в листинге 13-21 или версию с использованием итераторов в листинге 13-22. Большинство программистов на языке Rust предпочитают использовать стиль итераторов. Сначала разобраться с ним немного сложно, но как только вы почувствуете, что такое различные адаптеры итераторов и что они делают, понять итераторы станет проще. Вместо того чтобы возиться с различными элементами цикла и создавать новые векторы, код фокусируется на высокоуровневой цели цикла. Это абстрагирует часть обычного кода, поэтому легче увидеть концепции, уникальные для этого кода, такие как условие фильтрации, которое должен пройти каждый элемент в итераторе.

Но действительно ли эти две реализации эквивалентны? Интуитивно можно предположить, что более низкоуровневый цикл будет быстрее. Давайте поговорим о производительности.


[" Трейты как параметры"]: ch10-02-traits.html#traits-as-parameters