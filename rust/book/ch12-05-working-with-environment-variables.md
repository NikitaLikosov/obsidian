## Работа с переменными окружения

Мы улучшим `minigrep`, добавив дополнительную функцию: опцию для поиска без учёта регистра, которую пользователь может включить с помощью переменной среды окружения. Мы могли бы сделать эту функцию параметром командной строки и потребовать, чтобы пользователи вводили бы её каждый раз при её применении, но вместо этого мы будем использовать переменную среды окружения, что позволит нашим пользователям устанавливать переменную среды один раз и все поиски будут не чувствительны к регистру в этом терминальном сеансе.

### Написание ошибочного теста для функции `search` с учётом регистра

Мы, во-первых, добавим новую функцию `search_case_insensitive`, которую мы будем вызывать, когда переменная окружения содержит значение. Мы продолжим следовать процессу TDD, поэтому первый шаг - это снова написать не проходящий тест. Мы добавим новый тест для новой функции `search_case_insensitive` и переименуем наш старый тест из `one_result` в `case_sensitive`, чтобы прояснить различия между двумя тестами, как показано в листинге 12-20.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}
```

<span class="caption">Листинг 12-20. Добавление нового не проходящего теста для функции поиска нечувствительной к регистру, которую мы собираемся добавить</span>

Обратите внимание, что мы также отредактировали содержимое переменной `contents` из старого теста. Мы добавили новую строку с текстом `"Duct tape."`, используя заглавную D, которая не должна соответствовать запросу `"duct"` при поиске с учётом регистра. Такое изменение старого теста помогает избежать случайного нарушения функциональности поиска чувствительного к регистру, который мы уже реализовали. Этот тест должен пройти сейчас и должен продолжать выполняться успешно, пока мы работаем над поиском без учёта регистра.

Новый тест для поиска *нечувствительного* к регистру использует `"rUsT"` качестве строки запроса. В функции `search_case_insensitive`, которую мы собираемся реализовать, запрос `"rUsT"` должен соответствовать строке содержащей `"Rust:"` с большой буквы R и соответствовать строке `"Trust me."`, хотя обе имеют разные регистры из запроса. Это наш не проходящий тест, он не компилируется, потому что мы ещё не определили функцию `search_case_insensitive`. Не стесняйтесь добавлять скелет реализация, которая всегда возвращает пустой вектор, аналогично тому, как мы это делали для функции `search` в листинге 12-16, чтобы увидеть компиляцию теста и его сбой.

### Реализация функции `search_case_insensitive`

Функция `search_case_insensitive`, показанная в листинге 12-21, будет почти такая же, как функция `search`. Разница лишь в том, что текст будет в нижнем регистре для `query` и для каждой `line`, так что для любого регистра входных аргументов это будет тот же случай, когда мы проверяем, содержит ли строка запрос.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}
```

<span class="caption">Листинг 12-21. Определение функции <code>search_case_insensitive</code> с уменьшением регистра строки запроса и строки содержимого перед их сравнением</span>

Сначала преобразуем в нижний регистр строку `query` и сохраняем её в затенённой переменной с тем же именем. Вызов `to_lowercase` для строки запроса необходим, так что независимо от того, будет ли пользовательский запрос `"rust"` , `"RUST"`, `"Rust"` или `"rUsT"`, мы будем преобразовывать запрос к `"rust"` и делать значение нечувствительным к регистру. Хотя `to_lowercase` будет обрабатывать Unicode, он не будет точным на 100%. Если бы мы писали реальное приложение, мы бы хотели проделать здесь немного больше работы, но этот раздел посвящён переменным среды, а не Unicode, поэтому мы оставим это здесь.

Обратите внимание, что `query` теперь имеет тип `String`, а не срез строки, потому что вызов `to_lowercase` создаёт новые данные, а не ссылается на существующие.  К примеру, запрос: `"rUsT"` это срез строки не содержащий строчных букв `u` или `t`, которые мы можем использовать, поэтому мы должны выделить новую `String`, содержащую `«rust»`. Когда мы передаём запрос `query` в качестве аргумента метода `contains`, нам нужно добавить амперсанд, поскольку сигнатура `contains`, определена для приёмы среза строки.

Затем мы добавляем вызов `to_lowercase` для каждой строки `line` для преобразования к нижнему регистру всех символов. Теперь, когда мы преобразовали `line` и `query` в нижний регистр, мы найдём совпадения независимо от того, в каком регистре находится переменная с запросом.

Давайте посмотрим, проходит ли эта реализация тесты:

```console
{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}
```

Отлично! Тесты прошли. Теперь давайте вызовем новую функцию `search_case_insensitive` из функции `run`. Во-первых, мы добавим параметр конфигурации в структуру `Config` для переключения между поиском с учётом регистра и без учёта регистра. Добавление этого поля приведёт к ошибкам компилятора, потому что мы ещё нигде не инициализируем это поле:

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}
```

Мы добавили поле `ignore_case`, которое содержит логическое значение. Далее нам нужна функция `run`, чтобы проверить значение поля `ignore_case` и использовать его, чтобы решить, вызывать ли функцию `search` или функцию `search_case_insensitive`, как показано в листинге 12-22. Этот код все ещё не компилируется.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}
```

<span class="caption">Листинг 12-22. Вызов либо <code>search</code>, либо <code>search_case_insensitive</code> на основе значения в <code>config.ignore_case</code></span>

Наконец, нам нужно проверить переменную среды. Функции для работы с переменными среды находятся в модуле `env` стандартной библиотеки, поэтому мы хотим подключить этот модуль в область видимости в верхней части <em>src/lib.rs</em>. Затем мы будем использовать функцию `var` из модуля `env` для проверки установлено ли любое значение в переменной среды с именем `IGNORE_CASE`, как показано в листинге 12-23.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}
```

<span class="caption">Листинг 12-23. Проверка переменной среды с именем <code>IGNORE_CASE</code></span>

Здесь мы создаём новую переменную `ignore_case`. Чтобы установить её значение, мы вызываем функцию `env::var` и передаём ей имя переменной окружения `IGNORE_CASE`. Функция `env::var` возвращает `Result`, который будет успешным вариантом `Ok` содержащий значение переменной среды, если переменная среды установлена. Он вернёт вариант `Err`, если переменная окружения не установлена.

Мы используем метод `is_ok` у `Result`, чтобы проверить установлена ли переменная окружения, что будет означать, что программа должна выполнить поиск без учёта регистра. Если переменная среды `IGNORE_CASE` не содержит любого значения, то `is_ok` вернёт значение false и программа выполнит поиск c учётом регистра. Мы не заботимся о <em>значении</em> переменной среды, нас интересует только установлена она или нет, поэтому мы проверяем `is_ok`, а не используем `unwrap`, `expect` или любой другой метод, который мы видели у `Result`.

Мы передаём значение переменной `ignore_case` экземпляру `Config`, чтобы функция `run` могла прочитать это значение и решить, следует ли вызывать `search` или `search_case_insensitive`, как мы реализовали в листинге 12-22.

Давайте попробуем! Во-первых, мы запустим нашу программу без установленной переменной среды и с помощью значения запроса `to`, который должен соответствовать любой строке, содержащей слово «to» в нижнем регистре:

```console
{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}
```

Похоже, все ещё работает! Теперь давайте запустим программу с `IGNORE_CASE`, установленным в `1`, но с тем же значением запроса `to`.

```console
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

Если вы используете PowerShell, вам нужно установить переменную среды и запустить программу двумя командами, а не одной:

```console
PS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt
```

Это заставит переменную окружения `IGNORE_CASE` сохраниться до конца сеанса работы консоли. Переменную можно отключить с помощью команды `Remove-Item`:

```console
PS> Remove-Item Env:IGNORE_CASE
```

Мы должны получить строки, содержащие «to», которые могут иметь заглавные буквы:

<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->

```console
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

Отлично, мы также получили строки, содержащие «To»! Наша программа `minigrep` теперь может выполнять поиск без учёта регистра, управляемая переменной среды. Теперь вы знаете, как управлять параметрами, заданными с помощью аргументов командной строки или переменных среды.

Некоторые программы допускают использование аргументов *и* переменных среды для одной и той же конфигурации. В таких случаях программы решают, что из них имеет больший приоритет. Для другого самостоятельного упражнения попробуйте управлять чувствительностью к регистру с помощью аргумента командной строки или переменной окружения. Решите, аргумент командной строки или переменная среды будет иметь приоритет, если программа выполняется со значениями "учитывать регистр" в одном случае, и "игнорировать регистр" в другом.

Модуль `std::env` содержит много других полезных функций для работы с переменными среды: ознакомьтесь с его документацией, чтобы узнать доступные.
