## Пути для ссылки на элемент в дереве модулей

Чтобы показать Rust, где найти элемент в дереве модулей, мы используем путь так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать её путь.

Пути бывают двух видов:

- *абсолютный путь* - это полный путь, начинающийся от корневого модуля крейта; для кода из внешнего крейта абсолютный путь начинается с имени крейта, а для кода из текущего крейта он начинается с литерала `crate`.
- *относительный путь* начинается с текущего модуля и использует ключевые слова `self`, `super` или идентификатор в текущем модуле.

Как абсолютные, так и относительные, пути состоят из одного или нескольких идентификаторов, разделённых двойными двоеточиями (`::`).

Вернёмся к листингу 7-1, скажем, мы хотим вызвать функцию `add_to_waitlist`. Это то же самое, что спросить: какой путь у функции `add_to_waitlist`? В листинге 7-3 мы немного упростили код листинга 7-1, удалив некоторые модули и функции.

Мы покажем два способа вызова функции `add_to_waitlist` из новой функции `eat_at_restaurant`, определённой в корневом модуле крейта. Эти пути правильные, но остаётся ещё одна проблема, которая не позволит этому примеру скомпилироваться как есть. Мы скоро объясним почему.

Функция `eat_at_restaurant` является частью общедоступного API нашего библиотечного крейта, поэтому мы помечаем её ключевым словом `pub`. В разделе <a data-md-type="raw_html" href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">"Раскрываем приватные пути с помощью ключевого слова `pub`"</a><!-- ignore --> мы рассмотрим более подробно `pub`.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-03/src/lib.rs}}
```

<span class="caption">Листинг 7-3. Вызов функции <code>add_to_waitlist</code> с использованием абсолютного и относительного пути</span>

При первом вызове функции `add_to_waitlist` из `eat_at_restaurant` мы используем абсолютный путь. Функция `add_to_waitlist` определена в том же крейте, что и `eat_at_restaurant`, и это означает, что мы можем использовать ключевое слово `crate` в начале абсолютного пути. Затем мы добавляем каждый из последующих дочерних модулей, пока не составим путь до `add_to_waitlist`. Вы можете представить себе файловую систему с такой же структурой: мы указываем путь `/front_of_house/hosting/add_to_waitlist` для запуска программы `add_to_waitlist`; использование имени `crate` в качестве корневого модуля крейта аналогично использованию `/` для указания корня файловой системы в вашей оболочке.

Второй раз, когда мы вызываем `add_to_waitlist` из `eat_at_restaurant`, мы используем относительный путь. Путь начинается с имени модуля `front_of_house`, определённого на том же уровне дерева модулей, что и `eat_at_restaurant`. Для эквивалентной файловой системы использовался бы путь `front_of_house/hosting/add_to_waitlist`. Начало пути с имени модуля означает, что путь является относительным.

Выбор, использовать относительный или абсолютный путь, является решением, которое вы примете на основании вашего проекта. Решение должно зависеть от того, с какой вероятностью вы переместите объявление элемента отдельно от или вместе с кодом использующим этот элемент. Например, в случае перемещения модуля `front_of_house` и его функции `eat_at_restaurant` в другой модуль с именем `customer_experience`, будет необходимо обновить абсолютный путь до `add_to_waitlist`, но относительный путь всё равно будет действителен. Однако, если мы переместим отдельно функцию `eat_at_restaurant` в модуль с именем `dining`, то абсолютный путь вызова `add_to_waitlist` останется прежним, а относительный путь нужно будет обновить. Мы предпочитаем указывать абсолютные пути, потому что это позволяет проще перемещать определения кода и вызовы элементов независимо друг от друга.

Давайте попробуем скомпилировать код из листинга 7-3 и выяснить, почему он ещё не компилируется. Ошибка, которую мы получаем, показана в листинге 7-4.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-03/output.txt}}
```

<span class="caption">Листинг 7-4. Ошибки компиляции при сборке кода из листинга 7-3</span>

Сообщения об ошибках говорят о том, что модуль `hosting` является приватным. Другими словами, у нас есть правильные пути к модулю `hosting` и функции `add_to_waitlist`, но Rust не позволяет нам использовать их, потому что у него нет доступа к приватным разделам. В Rust все элементы (функции, методы, структуры, перечисления, модули и константы) по умолчанию являются приватными для родительских модулей. Если вы хотите сделать элемент, например функцию или структуру, приватным, вы помещаете его в модуль.

Элементы в родительском модуле не могут использовать приватные элементы внутри дочерних модулей, но элементы в дочерних модулях могут использовать элементы у своих модулях-предках. Это связано с тем, что дочерние модули оборачивают и скрывают детали своей реализации, но дочерние модули могут видеть контекст, в котором они определены. Продолжая нашу метафору, подумайте о правилах приватности как о задней части ресторана: то, что там происходит, скрыто от клиентов ресторана, но офис-менеджеры могут видеть и делать всё в ресторане, которым они управляют.

В Rust решили, что система модулей должна функционировать таким образом, чтобы по умолчанию скрывать детали реализации. Таким образом, вы знаете, какие части внутреннего кода вы можете изменять не нарушая работы внешнего кода. Тем не менее, Rust даёт нам возможность открывать внутренние части кода дочерних модулей для внешних модулей-предков, используя ключевое слово `pub`, чтобы сделать элемент общедоступным.

### Раскрываем приватные пути с помощью ключевого слова `pub`<a id="exposing-paths-with-the-pub-keyword"></a>

Давайте вернёмся к ошибке в листинге 7-4, которая говорит, что модуль `hosting` является приватным. Мы хотим, чтобы функция `eat_at_restaurant` из родительского модуля имела доступ к функции `add_to_waitlist` в дочернем модуле, поэтому мы помечаем модуль `hosting` ключевым словом `pub`, как показано в листинге 7-5.

<span class="filename">Файл: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-05/src/lib.rs}}
```

<span class="caption">Листинг 7-5. Объявление модуля <code>hosting</code> как <code>pub</code> для его использования из <code>eat_at_restaurant</code></span>

К сожалению, код в листинге 7-5 всё ещё приводит к ошибке, как показано в листинге 7-6.

```console
{{#include ../listings/ch07-managing-growing-projects/listing-07-05/output.txt}}
```

<span class="caption">Листинг 7-6: Ошибки компиляции при сборке кода в листинге 7-5</span>

Что произошло? Добавление ключевого слова `pub` перед `mod hosting` сделало модуль общедоступным. После этого изменения, если мы можем получить доступ к модулю `front_of_house`, то мы можем получить доступ к модулю `hosting`. Но *содержимое* модуля `hosting` всё ещё является приватным: превращение модуля в общедоступный модуль не делает его содержимое общедоступным. Ключевое слово `pub` позволяет внешнему коду в модулях-предках обращаться только к модулю, без доступа ко внутреннему коду. Поскольку модули являются контейнерами, мы мало что можем сделать, просто сделав модуль общедоступным; нам нужно пойти дальше и сделать один или несколько элементов в модуле общедоступными.

Ошибки в листинге 7-6 говорят, что функция `add_to_waitlist` является приватной. Правила приватности применяются к структурам, перечислениям, функциям и методам, также как и к модулям.

Давайте также сделаем функцию `add_to_waitlist` общедоступной, добавив ключевое слово `pub` перед её определением, как показано в листинге 7-7.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-07/src/lib.rs}}
```

<span class="caption">Листинг 7-7. Добавление ключевого слова <code>pub</code> к <code>mod hosting</code> и к <code>fn add_to_waitlist</code> позволяет нам вызывать функцию из <code>eat_at_restaurant</code></span>

Теперь код компилируется! Чтобы понять, почему добавление ключевого слова `pub` позволяет нам использовать эти пути для `add_to_waitlist` в соответствии с правилами приватности, давайте рассмотрим абсолютный и относительный пути.

В случае абсолютного пути мы начинаем с `crate`, корня дерева модулей нашего крейта. Модуль `front_of_house` определён в корневом модуле крейта. Хотя `front_of_house` не является общедоступным, но поскольку функция `eat_at_restaurant` определена в том же модуле, что и `front_of_house` (то есть, `eat_at_restaurant` и `front_of_house` являются потомками одного родителя), мы можем ссылаться на `front_of_house` из `eat_at_restaurant`. Далее идёт модуль `hosting`, помеченный как `pub`. Мы можем получить доступ к родительскому модулю модуля `hosting`, поэтому мы можем получить доступ и к `hosting`. Наконец, функция `add_to_waitlist` помечена как `pub`, и так как мы можем получить доступ к её родительскому модулю, то вызов этой функции разрешён!

В случае относительного пути логика такая же как для абсолютного пути, за исключением первого шага: вместо того, чтобы начинать с корневого модуля крейта, путь начинается с `front_of_house`. Модуль `front_of_house` определён в том же модуле, что и `eat_at_restaurant`, поэтому относительный путь, начинающийся с модуля, в котором определена `eat_at_restaurant` тоже работает. Тогда, по причине того, что `hosting` и `add_to_waitlist` помечены как `pub`, остальная часть пути работает и вызов этой функции разрешён!

Если вы планируете предоставить общий доступ к своему библиотечному крейту, чтобы другие проекты могли использовать ваш код, ваш общедоступный API — это ваш контракт с пользователями вашего крейта, определяющий, как они могут взаимодействовать с вашим кодом. Есть много соображений по поводу управления изменениями в вашем общедоступном API, чтобы сделать необременительным для людей зависимость от вашего крейта. Эти соображения выходят за рамки этой книги; если вам интересна эта тема, см. [The Rust API Guidelines].

> #### Лучшие практики для пакетов с бинарным и библиотечным крейтами
>
> Мы упоминали, что пакет может содержать как корневой модуль бинарного крейта *src/main.rs*, так и корневой модуль библиотечного крейта *src/lib.rs*, и оба крейта будут по умолчанию иметь имя пакета. Как правило, пакеты с таким шаблоном, содержащим как библиотечный, так и бинарный крейт, будут иметь достаточно кода в бинарном крейте, чтобы запустить исполняемый файл, который вызывает код из библиотечного крейта. Это позволяет другим проектам извлечь выгоду из большей части функциональности, предоставляемой пакетом, поскольку код библиотечного крейта можно использовать совместно.
>
> Дерево модулей должно быть определено в *src/lib.rs*. Затем любые общедоступные элементы можно использовать в бинарном крейте, начав пути с имени пакета. Бинарный крейт становится пользователем библиотечного крейта точно так же, как полностью внешний крейт использует библиотечный крейт: он может использовать только общедоступный API. Это поможет вам разработать хороший API; вы не только автор, но и пользователь!
>
> В [Главе 12]<!-- ignore --> мы эту практику организации кода с помощью консольной программы, которая будет содержать как бинарный, так и библиотечный крейты.

### Начинаем относительный путь с помощью `super`

Также можно построить относительные пути, которые начинаются в родительском модуле, используя ключевое слово `super` в начале пути. Это похоже на синтаксис начала пути файловой системы `..`. Использование `super` позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском модуле, что может упростить переупорядочение дерева модулей, чем когда модуль тесно связан с родителем, но родитель может когда-нибудь быть перемещён в другое место в дереве модулей.

Рассмотрим код в листинге 7-8, где моделируется ситуация, в которой повар исправляет неправильный заказ и лично приносит его клиенту. Функция `fix_incorrect_order` вызывает функцию `deliver_order`, определённую в родительском модуле, указывая путь к `deliver_order`, начинающийся с `super`:

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-08/src/lib.rs}}
```

<span class="caption">Листинг 7-8: Вызов функции с использованием относительного пути, начинающегося с <code>super</code></span>

Функция `fix_incorrect_order` находится в модуле `back_of_house`, поэтому мы можем использовать `super` для перехода к родительскому модулю модуля `back_of_house`, который в этом случае является `crate`, корневым модулем. В этом модуле мы ищем `deliver_order` и находим его. Успех! Мы думаем, что модуль `back_of_house` и функция `deliver_order`, скорее всего, останутся в тех же родственных отношениях друг с другом, и должны будут перемещены вместе, если мы решим реорганизовать дерево модулей крейта. Поэтому мы использовали `super`, чтобы в будущем у нас было меньше мест для обновления кода, если этот код будет перемещён в другой модуль.

### Делаем общедоступными структуры и перечисления

Мы также можем использовать `pub` для обозначения структур и перечислений как общедоступных, но есть несколько дополнительных деталей использования `pub` со структурами и перечислениями. Если мы используем `pub` перед определением структуры, мы делаем структуру общедоступной, но поля структуры по-прежнему остаются приватными. Мы можем сделать каждое поле общедоступным или нет в каждом конкретном случае. В листинге 7-9 мы определили общедоступную структуру `back_of_house::Breakfast` с общедоступным полем `toast` и с приватным полем `seasonal_fruit`. Это моделирует случай в ресторане, когда клиент может выбрать тип хлеба, который подаётся с едой, а шеф-повар решает какие фрукты сопровождают еду, исходя из того, что сезонно и что есть в наличии. Доступные фрукты быстро меняются, поэтому клиенты не могут выбирать фрукты или даже увидеть, какие фрукты они получат.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-09/src/lib.rs}}
```

<span class="caption">Листинг 7-9: Структура с общедоступными и приватными полями</span>

Поскольку поле `toast` в структуре `back_of_house::Breakfast` является открытым, то в функции `eat_at_restaurant` можно писать и читать поле `toast`, используя точечную нотацию. Обратите внимание, что мы не можем использовать поле `seasonal_fruit` в `eat_at_restaurant`, потому что `seasonal_fruit` является приватным. Попробуйте убрать комментирование с последней строки для значения поля `seasonal_fruit`, чтобы увидеть какую ошибку вы получите!

Также обратите внимание, что поскольку `back_of_house::Breakfast` имеет приватное поле, то структура должна предоставить публичную ассоциированную функцию, которая создаёт экземпляр `Breakfast` (мы назвали её `summer`). Если `Breakfast` не имел бы такой функции, мы бы не могли создать экземпляр `Breakfast` внутри `eat_at_restaurant`, потому что мы не смогли бы установить значение приватного поля `seasonal_fruit` в функции `eat_at_restaurant`.

В отличии от структуры, если мы сделаем общедоступным перечисление, то все его варианты будут общедоступными. Нужно только указать `pub` перед ключевым словом `enum`, как показано в листинге 7-10.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-10/src/lib.rs}}
```

<span class="caption">Листинг 7-10. Определяя перечисление общедоступным мы делаем все его варианты общедоступными</span>

Поскольку мы сделали общедоступным перечисление `Appetizer`, то можно использовать варианты `Soup` и `Salad` в функции `eat_at_restaurant`.

Перечисления не очень полезны, если их варианты не являются общедоступными: было бы досадно каждый раз аннотировать все варианты перечисления как `pub`. По этой причине по умолчанию варианты перечислений являются общедоступными. Структуры часто полезны, если их поля не являются общедоступными, поэтому поля структуры следуют общему правилу, согласно которому, всё по умолчанию является приватным, если не указано `pub`.

Есть ещё одна ситуация с `pub`, которую мы не освещали, и это последняя особенность модульной системы: ключевое слово `use`. Мы сначала опишем `use` само по себе, а затем покажем как сочетать `pub` и `use` вместе.


[The Rust API Guidelines]: https://rust-lang.github.io/api-guidelines/
[Главе 12]: ch12-00-an-io-project.html