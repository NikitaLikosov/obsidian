## Вопросы по JavaScript и React

1. Что такое Virtual DOM и как он работает?
	Virtual DOM — это облегчённая копия реального DOM, хранящаяся в оперативной памяти и представляющая текущее состояние пользовательского интерфейса в виде обычных JavaScript-объектов	
2. Как работает алгоритм сравнения (reconciliation) в React?
	Когда состояние приложения меняется, React создает новое дерево Virtual DOM, сравнивает его с предыдущим (diffing), и затем вносит только необходимые минимальные изменения в реальный DOM браузера, что позволяет обновлять интерфейс быстро и эффективно, избегая полной перерисовки страницы
3. Что такое хуки в React и с какими работал?
	Хуки — это функции начинающиеся с use и которые должны в том же порядке количестве вызываться каждый ререндер.
	 useState, useEffect, useContext, useMemo, useCallback, useRef
4. Зачем нужен key в React?
	Key нужен, чтобы React не путал элементы в списках; без него могут сбиваться состояния компонентов, появляться неправильные данные и баги при анимациях или удалении элементов
5. Чем useEffect отличается от useLayoutEffect?
	useEffect срабатывает после рендера, не блокирует отрисовку, подходит для запросов и подписок;
	useLayoutEffect выполняется синхронно до отрисовки, нужен для работы с DOM без миганий и артефактов
6. Как использовать рефы (refs) в React и для чего они нужны?
	Refs позволяют получать доступ к DOM и хранить значения между рендерами без перерисовки компонента; чтобы родитель мог прокинуть ref в ваш компонент (например, для доступа к внутреннему input), используйте обёртку `forwardRef`, которая позволяет принимать и передавать ref дальше внутри компонента
7. Чем отличается useMemo от useCallback?
	**useMemo** мемоизирует результат вычисления функции и возвращает значение, только если зависимости изменились.  
	**useCallback** мемоизирует саму функцию, возвращая ту же ссылку на функцию между рендерами, если зависимости не изменились.  
	useMemo используют для оптимизации тяжёлых вычислений, useCallback — для предотвращения лишних перерендеров дочерних компонентов, которым передаются функции как пропсы.
8. Что такое Fragment в React и для чего он используется?
	**Fragment** — это специальный компонент, позволяющий группировать несколько элементов без добавления лишних узлов в DOM. Используется для возврата нескольких элементов из компонента без оборачивания их в дополнительный div.
9. Что такое Higher-Order Components (HOC) и для чего они используются?
	**HOC** — это функция, принимающая компонент и возвращающая новый компонент с расширенной функциональностью. Используется для переиспользования логики между компонентами (например, обработка данных, авторизация, подписки).
10. Специфичность CSS.
	Специфичность — это правило, определяющее, какой стиль применится к элементу, если на него действуют несколько CSS-правил; чем выше специфичность селектора, тем выше его приоритет. Инлайн-стили — 1000; ID-селекторы — 100; Классы, атрибуты, псевдоклассы — 10; Теги и псевдоэлементы — 1
11. Какие есть варианты для хранения данных на фронтенде? В чем их различия (localStorage, sessionStorage, cookie)?
	•	indexDB: хранит до Infinity МБ данных бессрочно, доступен во всех вкладках одного домена, можно хранить не только строки!.
	•	localStorage: хранит до 5 МБ данных бессрочно, доступен во всех вкладках одного домена.
	•	sessionStorage: хранит до 5 МБ только в одной вкладке и только до её закрытия, каждая вкладка — отдельное хранилище.
	•	cookie: ограничение ~4 КБ, могут быть сессии или иметь срок действия, автоматически отправляются на сервер с каждым запросом, поддерживают флаги безопасности и доступны как на клиенте, так и на сервере.
12. Что такое Web API?
	**Web API** — это интерфейсы, предоставляемые браузером для взаимодействия с функциональностью устройства или веб-страницы (например, DOM API, Fetch API, LocalStorage API).
13. Чем отличается использование Promise и async/await?
	async/await лучше для линейных сценариев, а промисы нужны для сложной параллельщины и управления состояниями сразу нескольких задач. async может все то же что и Promise но не наоборот!
14. Какие есть способы привязать контекст (bind, call, apply)? В чем разница?
	- **bind**: возвращает новую функцию с привязанным контекстом.
	- **call**: вызывает функцию с указанным контекстом и аргументами.
	- **apply**: вызывает функцию с указанным контекстом и массивом аргументов.
15. Что такое контекст выполнения? Что такое this?
	Контекст выполнения — это
		•	текущее лексическое окружение (scope),
		•	значение this или undefined,
		•	внешнее лексическое окружение (scope chain).
	this всегда указывает на объект, в контексте которого вызвана функция.
16. Какие ты знаешь методы самого класса Promise?
	-  Promise.resolve — создаёт успешно завершённый промис.
	- Promise.reject — создаёт отклонённый промис.
	- Promise.all — ждёт, пока все промисы выполнятся, либо выдаёт ошибку при первом отказе.
	- Promise.race — возвращает результат первого завершившегося промиса (успех или ошибка).
	- Promise.allSettled — ждёт завершения всех промисов, возвращает их статусы и значения/ошибки.
	- Promise.any — ждёт первый успешно выполненный промис, если все с ошибкой — выдаёт ошибку
17. Как работает замыкание?
	**Замыкание** — это функция, которая запоминает своё лексическое окружение даже после выхода из области видимости, позволяя обращаться к переменным из внешней функции. **Не во всех языках такое есть!**
18. Отличия стрелочной функции от function declaration.
	- У стрелочных функций **никогда** нет собственного this, arguments.
	- Стрелочные функции не могут быть конструкторами.
19. Как устроен сборщик мусора в JS? Условие достижимости.
	Сборщик мусора удаляет объекты, к которым нет достижимых ссылок. Если на объект нельзя добраться из корня (global, локальные переменные, цепочка ссылок), он становится недостижимым и подлежит удалению.
20. Что такое рекурсия и чем она опасна?
	**Рекурсия** — функция вызывает саму себя. Опасность: переполнение **стека(scoup)**.
21. Что такое всплытие и погружение событий (event propagation)?
	Event propagation (распространение событий) включает две основные фазы:
		•	Погружение (capturing, trickling) — событие идёт сверху вниз: от корня (document) к целевому элементу.
		•	Всплытие (bubbling) — событие идёт снизу вверх: от целевого элемента обратно к корню.
	Между ними есть target phase — событие достигло целевого элемента
22. Что такое вспомогательные типы (Utility Types)? Какие знаете?
	Utility Types — встроенные типы TypeScript для изменения других типов.
		•	Partial — делает все поля типа T необязательными
		•	Required — делает все поля типа T обязательными
		•	Readonly — делает все поля только для чтения
		•	Pick<T, K> — выбирает из T только указанные поля K
		•	Omit<T, K> — исключает из T указанные поля K
		•	Record<K, T> — объект с ключами K и значениями типа T
		•	ReturnType — тип возвращаемого значения функции T
		•	Parameters — тип кортежа аргументов функции T
23. Что такое обобщения (Generics)?
	Generics — это параметризованные типы, которые позволяют создавать универсальные функции, классы и интерфейсы с сохранением строгой типизации, подставляя конкретные типы при использовании.
24. Что такое ограничение обобщений? Как сузить тип?
	Ограничение обобщений (extends) позволяет задать, от какого типа может наследоваться generic-параметр, например: `<T extends SomeType>`.
	Type Guard (гвард типов) — это функция или конструкция, которая уточняет тип generic-параметра во время исполнения, позволяя работать только с нужным подтипом (например, с помощью `typeof`, `instanceof` или пользовательских функций-гвардов). `function isString(x: unknown): x is string {return typeof x === 'string'}`
	Структурная типизация (structural typing) в TypeScript означает, что ограничение generic-параметра проверяется не по имени типа, а по наличию нужных свойств/методов — если объект “подходит по структуре”, он будет принят.
25. Какие интересные случаи приходилось настраивать в tsconfig?
	 Настройка strict режимов, path alias, включение/исключение файлов, поддержка JSX, target, module, declaration. Конфиги для тестов
26. . Какие интересные случаи приходилось настраивать в eslint?
	Настройка правил для типов, форматирования, кастомные плагины, интеграция с Prettier, отключение/включение специфичных правил для проекта. Цикломатическая сложность.
27. Из чего состоит HTTP-запрос?
	Стартовая строка (метод, путь, версия, query), заголовки, тело.
28. Что такое CORS и для чего он нужен?
	CORS (Cross-Origin Resource Sharing) — механизм, позволяющий браузеру контролировать доступ к ресурсам с другого домена, защищая от несанкционированных запросов.
29. Что такое cookie и для чего они используются? Зачем нужен флаг HttpOnly?
	Cookie — небольшие данные, хранящиеся в браузере, используются для хранения сессий, авторизации, настроек.  Отправляются на сервер с каждым запросом.
	HttpOnly защищает cookie от доступа через JavaScript, предотвращая XSS-атаки.
30. Какие ограничения существуют для cookie?
	Cookie ограничены по размеру — около 4 КБ на одну cookie и лимитом на количество (обычно 20–50 на домен), имеют ограничения по безопасности: флаги Secure (только HTTPS), HttpOnly (недоступна для JS) и SameSite (контроль кросс-доменных запросов), а также зависят от времени жизни и области действия по домену и пути; превышение лимитов приводит к удалению старых cookie или ошибкам.
31. Объясните разницу между HTTP и HTTPS.
	**HTTP** — нешифрованный протокол передачи данных.  
	**HTTPS** — защищённый протокол, использующий TLS/SSL для шифрования данных между клиентом и сервером. handshake  обмен рукопожатиями там. Сертификат нужен!
32. Какие есть способы клонировать объект в JavaScript?
	- Object.assign({}, obj) // не deepclone!!!
	- {...obj} // не deepclone!!!
	- JSON.parse(JSON.stringify(obj))
	- structuredClone(obj)
33. Чем отличается оператор "||" от "??" ?
	- || возвращает первый истинный операнд (falsy-значения: false, 0, '', null, undefined, NaN).
	- ?? возвращает первый операнд, который не null и не undefined.
34. Как оптимизировать приложение (метрики FCP, LCP, CLS и т.д.)?
	FCP (First Contentful Paint, “Время до первого отображения контента”)
	Для ускорения FCP минимизируйте критический CSS, инлайньте стили для первого экрана, используйте font-display: swap для шрифтов, приоритезируйте загрузку ключевого контента и откладывайте неважные ресурсы, чтобы первый видимый элемент появился максимально быстро.
	LCP (Largest Contentful Paint, “Время до отображения самого крупного элемента”)
	Для улучшения LCP оптимизируйте и сжимайте крупные изображения (используйте современные форматы), прелоадьте ключевые ресурсы, минимизируйте и асинхронно загружайте CSS/JS, используйте CDN и не лениво грузите важные элементы первого экрана, чтобы самый большой видимый элемент отображался как можно раньше.
	CLS (Cumulative Layout Shift, “Совокупное смещение макета”)
	Для снижения CLS всегда задавайте размеры для изображений, видео и iframes, резервируйте место под рекламу и динамический контент, избегайте внезапных изменений DOM без пользовательских действий и используйте font-display: swap/optional для шрифтов, чтобы макет оставался стабильным при загрузке.
35. Какие инструменты для анализа производительности используешь (Lighthouse, Performance, Network и т.д.)?
	Lighthouse, вкладки Performance и Network в DevTools, профилировщик React.
36. Что такое и для чего нужны WebRTC, WebSocket?
	- WebRTC — технология для передачи аудио, видео и данных между браузерами напрямую (peer-to-peer) или нет. Приоритет на UDP
	- WebSocket — протокол для двусторонней связи между клиентом и сервером в реальном времени. Только TCP. Может передавать байты
37. Что такое Shadow DOM?
	Shadow DOM — технология инкапсуляции DOM и стилей внутри компонента, предотвращающая влияние внешних стилей и скриптов.
38. Из-за чего может произойти перерендер компонента в React?
	Изменение props, state, контекста, forceUpdate(В классовых компонентах).
39. Что такое Big O и как считается сложность алгоритма?
	Big O — обозначение асимптотической сложности алгоритма, показывающее, как изменяется время или память при росте объёма входных данных.
	Чтобы посчитать сложность алгоритма, нужно определить, сколько элементарных операций выполняется в зависимости от размера входных данных, отбросить константы и оставить только самый быстрорастущий член.
40. В чем отличие Pick и Omit в TypeScript?
	- Pick создаёт тип с выбранными свойствами из другого типа.
	- Omit создаёт тип, исключая указанные свойства из другого типа.
41. Какие хуки появились в React 19?
	•	use(Promise) — позволяет “подвесить” компонент до выполнения промиса, что даёт возможность удобно получать данные прямо в рендере, а также вызывать этот хук внутри условий и циклов, чего раньше не позволяли другие хуки.
	•	useOptimistic — облегчает реализацию оптимистичных обновлений UI: вы сразу показываете пользователю предполагаемый результат, а когда асинхронная операция завершится, React автоматически обновит интерфейс в зависимости от её исхода.
	•	useActionState — управляет состоянием асинхронных действий (например, отправкой формы), возвращает результат последнего действия и статус выполнения, что упрощает обработку ошибок и отображение прогресса в интерфейсе.
42. Какие знаешь паттерны проектирования?
		Реальность
		•	Составные компоненты (Compound Components): группа связанных компонентов управляется общим родителем, что позволяет гибко комбинировать их внутри контейнера.
		•	Композиция (Composition Pattern): сложные компоненты строятся из простых и независимых, которые свободно комбинируются через вложенность и props.
		•	Использование props.children: компонент принимает любые дочерние элементы, позволяя гибко наполнять его содержимым.
		•	Render Props: компонент принимает функцию в качестве пропса или дочернего элемента для динамического управления рендером.
		•	Provider Pattern (Контекст): данные или функции передаются глубоко по дереву компонентов через контекст, минуя props.
		----------
		Искаженная реальность!
		•	Singleton (Одиночка) — гарантирует, что в приложении существует только один экземпляр класса, и предоставляет к нему глобальный доступ.
		•	Factory (Фабрика) — создает объекты определенного типа, скрывая детали их создания и позволяя менять конкретные реализации без изменения клиентского кода.
		•	Observer (Наблюдатель) — обеспечивает автоматическое оповещение связанных объектов об изменениях состояния другого объекта, реализуя принцип подписки.
		•	Decorator (Декоратор) — динамически добавляет объектам новое поведение, оборачивая их в дополнительные классы-обертки, не изменяя исходный код.
		•	Strategy (Стратегия) — позволяет выбирать алгоритм поведения объекта на лету, инкапсулируя различные алгоритмы в отдельные классы.
		•	Adapter (Адаптер) — преобразует интерфейс одного класса в интерфейс, ожидаемый клиентом, обеспечивая совместимость между несовместимыми интерфейсами.
		•	Facade (Фасад) — предоставляет упрощённый интерфейс к сложной системе или набору классов, скрывая их внутреннюю структуру.
43. Какие подходы проектирования знаешь (KISS, DRY, SOLID, YAGNI)?
	- KISS (Keep It Simple, Stupid): делай проще, избегай ненужной сложности.
	-  DRY (Don’t Repeat Yourself): не дублируй код, выноси повторяющееся в отдельные сущности.
	-  YAGNI (You Aren’t Gonna Need It): не реализуй то, что не требуется прямо сейчас.
	-  SOLID: пять принципов ООП для гибкости и поддержки кода (Single responsibility, Open/closed, Liskov substitution, Interface segregation, Dependency inversion).
44. Какие уязвимости знаешь и как их фиксить?
	XSS (экранирование данных), CSRF (токены), SQL-инъекции (параметризация), уязвимости авторизации (валидация прав), небезопасные cookie (HttpOnly, Secure).
45. Если у нас небольшой проект и не хочется тащить Redux, какие есть альтернативы?
	React Context, Zustand, react tanstack query.
46. React Query vs Redux: сходства, различия, взаимозаменяемость.
	React Query — для работы с серверными данными (кэш, синхронизация, автоматические запросы).  
	Redux — для управления состоянием приложения (любой тип данных).  
47. Что такое RTK Query?
	RTK Query — инструмент из Redux Toolkit для работы с асинхронными запросами и кэшированием данных.
48. Что такое Redux Saga?
	Redux Saga — middleware для Redux, позволяющий управлять побочными эффектами через генераторы.
49. Помимо React Hook Form, какие ещё есть варианты работы с формами?
	Formik, Redux Form, useFormState, кастомные решения.
50. Promise и async/await: какая между ними взаимосвязь?
	async/await — синтаксический сахар для работы с Promise. async-функция всегда возвращает Promise.
51. Зачем нужны кастомные хуки в React?
	 Доступ к хукам в функции
52. Что такое SOLID?
	•	Single Responsibility Principle (Принцип единственной ответственности): класс должен отвечать только за одну задачу или иметь одну причину для изменения.
	•	Open/Closed Principle (Принцип открытости/закрытости): класс должен быть открыт для расширения, но закрыт для изменения исходного кода.
	•	Liskov Substitution Principle (Принцип подстановки Лисков): дочерний класс должен полностью заменять родительский без нарушения работы программы.
	•	Interface Segregation Principle (Принцип разделения интерфейса): не заставляй класс реализовывать интерфейсы, которые он не использует.
	•	Dependency Inversion Principle (Принцип инверсии зависимостей): модули должны зависеть от абстракций, а не от конкретных реализаций.
53. Работал ли с валидацией данных на фронте?
	Да, реализовывал валидацию с помощью кастомных функций, библиотек (Yup, Joi), встроенных возможностей HTML.
54. Что такое прототипы в JavaScript и зачем они нужны?
	Прототип — это объект, от которого наследуются свойства и методы других объектов. Позволяет реализовать наследование и переиспользование кода.
55. Этапы рендера (rendering pipeline) в браузере
	 Включают несколько последовательных шагов, которые обеспечивают преобразование HTML, CSS и JavaScript в видимую картинку на экране пользователя. Ключевые этапы, связанные с понятиями reflow (layout) и paint (отрисовка), выглядят следующим образом:
	1.	Парсинг HTML и CSS
	•	Браузер строит DOM (Document Object Model) из HTML и CSSOM (CSS Object Model) из CSS.
	2.	Построение дерева рендера (render tree)
	•	DOM и CSSOM объединяются в render tree, который содержит только видимые элементы и их стили.
	3.	Компоновка (Layout, Reflow)
	•	На этом этапе для каждого элемента дерева рендера вычисляются точные размеры и положение на странице.
	•	Reflow (или relayout) происходит каждый раз, когда изменяются структура DOM, стили, размеры или положение элементов. Это затратный процесс, так как может затронуть множество элементов на странице.
	4.	Отрисовка (Paint, Repaint)
	•	После layout браузер превращает элементы render tree в пиксели на экране: рисует текст, цвета, изображения, тени и границы.
	•	Repaint выполняется, когда изменяются только визуальные свойства (например, цвет или фон), не влияющие на размеры и расположение элементов. Это менее затратный процесс по сравнению с reflow.
	5.	Композиция (Compositing, при необходимости)
	•	Иногда браузер разбивает страницу на слои, чтобы ускорить отрисовку, особенно при анимациях или использовании свойств вроде transform и opacity. Эти слои могут объединяться на GPU для повышения производительности 
56. React Fiber как работает?
57. React Fiber как работает?

## Git мерзавец
1. **Чем отличается git rebase от git merge?**  
`git merge` объединяет истории веток, создавая дополнительный коммит слияния, история становится разветвлённой. `git rebase` "переписывает" коммиты вашей ветки поверх другой, делая историю линейной и чище, но меняет хэши коммитов.
2. **Чем отличается git pull от git fetch?**  
`git fetch` только скачивает изменения с удалённого репозитория, не изменяя вашу рабочую ветку. `git pull` делает то же самое, но сразу выполняет слияние (`merge`) этих изменений с вашей текущей веткой.
3. **Что такое git blame?**  
Команда показывает, кто и когда изменил каждую строку файла — удобно для поиска автора изменений и истории строк.
4. **Что делает git cherry-pick?**  
Команда переносит отдельный коммит (или несколько коммитов) из одной ветки в другую, сохраняя их изменения.
5. **Как организовать ветвление в проекте с несколькими окружениями (dev, staging, prod) и регулярными релизами?**  
Часто используют отдельные ветки для каждого окружения:  
- `develop` — для разработки  
- `staging` — для тестирования  
- `main` или `master` — для продакшена  
Релизы оформляются через pull/merge requests между этими ветками, фиксы и новые фичи интегрируются через feature-ветки.
5. **Что такое TBD (Trunk Based Development)?**  
Это подход, при котором большинство разработчиков работают в одной основной ветке (`trunk`, обычно `main`), а новые изменения быстро интегрируются в неё через короткоживущие ветки или сразу коммитятся в основной поток.



Как eventloop связан с реендером?
как работает реквест анимэйшен фрейм?

Что важно запомнить
Если ты хочешь успешно проходить собеседования, нужно не просто знать теорию, а
понимать, как отвечать так, чтобы тебя хотели взять в команду. Так вышло, что сейчас
HR важно слышать ключевые слова, а не размышления.
Проанализируй свои пробелы – посмотри, какие темы тебе нужно подтянуть и
отрабатывай их на реальных задачах.
Отработай собеседования – попробуй ответить на вопросы вслух, объясняя так,
как будто учишь другого. Или запишись на МОК, будет круче и эффективнее.