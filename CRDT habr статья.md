## CRDT без страха: как работает Yjs на пальцах — от G-Counter до совместного редактирования текста

Представьте: вы и коллега в разных уголках планеты, но курсоры ваши встречаются в одном и том же тексте. Вы одновременно вставляете одно и то же слово в одну и ту же позицию — но у каждого оно своё. Или вы удаляете фрагмент, который ваш коллега в этот момент редактирует. Казалось бы, результат должен превратиться в хаос, но всё складывается в единую, логичную версию текста — несмотря на расстояния, задержки и одновременные правки.
На деле за этим волшебством часто скрываются CRDT — структуры данных, которые позволяют всем видеть одну и ту же картину без центрального дирижёра. Я сам столкнулся с этим, когда работал над коллаборативным редактором: CRDT и библиотека Yjs буквально спасли мой проект от хаоса и сделали синхронизацию прозрачной.
Давайте шаг за шагом разберёмся, как устроена эта инженерная магия. Начнём с самых простых структур, чтобы наглядно понять принципы CRDT, а затем постепенно усложним примеры — и вы увидите, как из базовых кирпичиков вырастают надёжные коллаборативные структуры. Спойлер: это гораздо проще, чем кажется.

## G-Counter — самый простой CRDT
Для начала — самый базовый пример: распределённый счётчик, который умеет только увеличиваться. Каждый участник системы ведёт свой собственный счёт, а при обмене данными с другими участниками объединяет состояния. Вот как это выглядит на JS:
```js
class GCounter {
  constructor(id) {
    this.id = id;
    this.state = { [id]: 0 };
  }

  inc() {
    this.state[this.id] = (this.state[this.id] || 0) + 1;
  }

  value() {
    return Object.values(this.state).reduce((a, b) => a + b, 0);
  }

  merge(counter) {
    for (const key in counter.state) {
      this.state[key] = Math.max(this.state[key] || 0, counter.state[key]);
    }
  }
}
```
Каждый участник хранит свою копию счётчика и может увеличивать только своё значение. При обмене состояниями любые две реплики просто сливают свои данные, беря максимум по каждому идентификатору. Итоговая сумма всегда будет одинаковой на всех участниках, независимо от порядка и количества слияний.

## Какие правила CRDT выполняются на примере G-Counter и зачем это нужно
##### Коммутативность:
`merge(a, b)` и `merge(b, a)` дают одинаковый результат. Например, если у двух участников такие состояния: `{A: 2, B: 0}` и `{A: 1, B: 3}`, после объединения у обоих будет `{A: 2, B: 3}` — не важно, кто первым отправил данные.
```js
const counterA = new GCounter('A');
const counterB = new GCounter('B');

counterA.inc(); // {A: 1} 
counterB.inc(); // {B: 1}

counterA.merge(counterB);
counterB.merge(counterA);

console.log(counterA.value()); // {A: 1, B: 1} = 2
console.log(counterB.value()); // {B: 1, A: 1} = 2
```
##### Ассоциативность:
Можно объединять состояния по парам в любом порядке: `merge(merge(a, b), c)` равно `merge(a, merge(b, c))`. Это важно, если участников больше двух — результат всё равно совпадает.
```js
const counterA = new GCounter('A');
const counterB = new GCounter('B');
const counterC = new GCounter('С');

counterA.inc(); // {A: 1} 
counterA.inc(); // {A: 2}
counterC.inc(); // {C: 1}

console.log(counterC.merge(counterB.merge(counterA)).value() === counterC.merge(counterA.merge(counterB)).value()) // {A: 2, B: 0, C: 1} = 2 = {B: 1, A: 2, C: 0}
```
##### Идемпотентность:
Если несколько раз объединить одно и то же состояние `merge(a, a)`, ничего не изменится. Например, если участник случайно получит дубликат состояния, итоговая сумма не увеличится.
```js
const counterA = new GCounter('A');

const counterB = new GCounter('B');
counterB.inc(); // A: 1, B: 0

counterA.merge(counterA.state);
console.log(counterB.value()); // 1
counterA.merge(counterA.state);
console.log(counterB.value()); // 1
//...
```
	
Прямое следствие коммутативности, ассоциативности и идемпотентности операций объединения является сходимость структуры к одному состоянию. Именно это свойство делают возможным автоматическое разрешение конфликтов и гарантируют, что все участники всегда придут к единому состоянию без централизованного контроля. Благодаря этому мы можем уверенно использовать CRDT в распределённых системах, где согласованность достигается сама собой.

### Массивы
Теперь когда мы поняли как устроены crdt структуры давайте попробуем сделать что то сложнее. Рассмотрим как нам сделать crdt массив(или текст)
В отличие от чисел, тут важен не только набор элементов, но и их порядок.  Индексы быстро становятся ненадёжными: если кто-то вставил или удалил символ до вашей позиции, ваш индекс уже не соответствует ожидаемому месту. Одним из классических решений является RGA (Replicated Growable Array). В этой структуре:
•	Каждый элемент получает уникальный идентификатор (часто на основе времени и пользователя)
•	Вставка происходит не по индексу, а после конкретного существующего элемента (по его id)
•	Удаление — это логическая пометка, а не физическое удаление (tombstone)
Вот пример	
```js
class RGAElement {
  constructor(id, value, deleted = false) {
    this.id = id; // уникальный id (например, [время, id пользователя])
    this.value = value;
    this.deleted = deleted;
    this.next = [];
  }
}

class RGA {
  constructor() {
    this.elements = {}; // id -> RGAElement
    this.head = new RGAElement('head', null);
    this.elements['head'] = this.head;
  }

  insert(afterId, id, value) {
    const elem = new RGAElement(id, value);
    this.elements[id] = elem;
    this.elements[afterId].next.push(id);
  }

  delete(id) {
    if (this.elements[id]) {
      this.elements[id].deleted = true;
    }
  }

  // обход для получения текста
  toText() {
    const traverse = (id) => {
      let res = '';
      for (const nextId of this.elements[id].next) {
        if (!this.elements[nextId].deleted) {
          res += this.elements[nextId].value;
        }
        res += traverse(nextId);
      }
      return res;
    };
    return traverse('head');
  }
}
```

В реальных CRDT (например, Yjs) используются усовершенствованные версии RGA: добавляются оптимизации для уменьшения размера структуры, сборка мусора для удалённых элементов и другие улучшения производительности.

Преимущества RGA
	•	Нет конфликтов при одновременных изменениях.
	•	Сходимость: все участники, независимо от порядка получения изменений, приходят к одному и тому же состоянию.
	•	Уникальные id позволяют однозначно определить порядок элементов.
В реальных CRDT (например, Yjs) используются усовершенствованные версии RGA: добавляются оптимизации для уменьшения размера структуры, сборка мусора для удалённых элементов и другие улучшения производительности.
Кратко:
Для совместного редактирования текста требуется особый подход, поскольку простые индексы не работают при параллельных изменениях. RGA и подобные структуры используют уникальные идентификаторы и логическое удаление, что позволяет всем участникам видеть одну и ту же версию текста без конфликтов и централизованного контроля.

**2. Переход к более сложным структурам: массивы и текст**
- Почему для текста нужен другой подход
- Кратко о проблемах индексов и вставок в тексте

**3. RGA**
- Пример работы RGA в js
- Что такое RGA и как он работает (уникальные id, вставка после элемента, логическое удаление)
- Как RGA решает проблему одновременных изменений

**4. Yjs: как устроено совместное редактирование на практике**
- Основные структуры данных Yjs (shared types: текст, массивы, карты)[2][4][5]
- Как Yjs реализует RGA/YATA и чем отличается от других CRDT[2][4]
- Кратко о производительности и оптимизациях Yjs (например, слияние структур, сборка мусора)[2][4]

**5. Пример: как выглядит код на Yjs**
- Минимальный пример создания документа, вставки, синхронизации
- Как легко интегрировать Yjs в свой проект

**6. Почему это не так сложно, как кажется**
- Сравнение с другими подходами (OT)
- Какие задачи Yjs решает «из коробки»
- Мифы о сложности CRDT и реальность

**Заключение**
- Куда копать дальше: ссылки на документацию, демо, обсуждения
- Призыв попробовать Yjs в своём проекте

---

**Примечание:**  
План выстроен от простого к сложному, с акцентом на практику и снятие страха перед CRDT и Yjs.