## CRDT без страха: как работает Yjs на пальцах — от G-Counter до совместного редактирования текста

Представьте: вы и коллега в разных уголках планеты, но курсоры ваши встречаются в одном и том же тексте. Вы одновременно вставляете слова в одну и ту же позицию или  удаляете фрагмент, который ваш коллега в этот момент редактирует. Казалось бы, результат должен превратиться в хаос, но всё складывается в единую, логичную версию текста — несмотря на расстояния, задержки и одновременные правки.
На деле за этим волшебством часто скрываются CRDT — структуры данных, которые позволяют всем видеть одну и ту же картину без центрального дирижёра. Я сам столкнулся с этим, когда работал над коллаборативным редактором: CRDT и библиотека Yjs буквально спасли мой проект от хаоса и сделали синхронизацию прозрачной.
Давайте шаг за шагом разберёмся, как устроена эта инженерная магия. Начнём с самых простых структур, чтобы наглядно понять принципы CRDT, а затем постепенно усложним примеры — и вы увидите, как из базовых кирпичиков вырастают надёжные коллаборативные структуры. Спойлер: это гораздо проще, чем кажется.

## G-Counter — самый простой CRDT
Для начала — самый базовый пример: распределённый счётчик, который умеет только увеличиваться. Каждый участник системы ведёт свой собственный счёт, а при обмене данными с другими участниками объединяет состояния. Вот как это выглядит на JS:
```js
class GCounter {
  constructor(id) {
    this.id = id;
    this.state = { [id]: 0 };
  }

  inc() {
    this.state[this.id] += 1;
  }

  value() {
    return Object.values(this.state).reduce((a, b) => a + b, 0);
  }

  merge(counter) {
    for (const key in counter.state) {
      this.state[key] = Math.max(this.state[key] || 0, counter.state[key]);
    }
  }
}
```
Каждый участник хранит свою копию счётчика и может увеличивать только своё значение. При обмене состояниями любые две реплики просто сливают свои данные, беря максимум по каждому идентификатору. Итоговая сумма всегда будет одинаковой на всех участниках, независимо от порядка и количества слияний.

## Какие правила CRDT выполняются на примере G-Counter и зачем это нужно
##### Коммутативность:
`merge(a, b)` и `merge(b, a)` дают одинаковый результат. Например, если у двух участников такие состояния: `{A: 2, B: 0}` и `{A: 1, B: 3}`, после объединения у обоих будет `{A: 2, B: 3}` — не важно, кто первым отправил данные.
```js
const counterA = new GCounter('A');
const counterB = new GCounter('B');

counterA.inc(); // {A: 1} 
counterB.inc(); // {B: 1}

counterA.merge(counterB);
counterB.merge(counterA);

console.log(counterA.value()); // {A: 1, B: 1} = 2
console.log(counterB.value()); // {B: 1, A: 1} = 2
```
##### Ассоциативность:
Можно объединять состояния по парам в любом порядке: `merge(merge(a, b), c)` равно `merge(a, merge(b, c))`. Это важно, если участников больше двух — результат всё равно совпадает.
```js
const counterA = new GCounter('A');
const counterB = new GCounter('B');
const counterC = new GCounter('С');

counterA.inc(); // {A: 1} 
counterA.inc(); // {A: 2}
counterC.inc(); // {C: 1}

console.log(counterC.merge(counterB.merge(counterA)).value() === counterC.merge(counterA.merge(counterB)).value()) // {A: 2, B: 0, C: 1} = 2 = {B: 1, A: 2, C: 0}
```
##### Идемпотентность:
Если несколько раз объединить одно и то же состояние `merge(a, a)`, ничего не изменится. Например, если участник случайно получит дубликат состояния, итоговая сумма не увеличится.
```js
const counterA = new GCounter('A');

const counterB = new GCounter('B');
counterB.inc(); // A: 1, B: 0

counterA.merge(counterA.state);
console.log(counterB.value()); // 1
counterA.merge(counterA.state);
console.log(counterB.value()); // 1
//...
```
	
Прямое следствие коммутативности, ассоциативности и идемпотентности операций объединения является сходимость структуры к **одному состоянию**. Именно это свойство делают возможным автоматическое разрешение конфликтов и гарантируют, что все участники всегда придут к единому состоянию без централизованного контроля. Благодаря этому мы можем уверенно использовать CRDT в распределённых системах, где согласованность достигается сама собой.

### Массивы
Теперь когда мы поняли как устроены crdt структуры давайте попробуем сделать что то сложнее. Рассмотрим как нам сделать crdt массив(или текст)
В отличие от чисел, тут важен не только набор элементов, но и их порядок.  Индексы быстро становятся ненадёжными: если кто-то вставил или удалил символ до вашей позиции, ваш индекс уже не соответствует ожидаемому месту. Одним из классических решений является RGA (Replicated Growable Array). В этой структуре:
•	Каждый элемент получает уникальный идентификатор (часто на основе времени и пользователя)
•	Вставка происходит не по индексу, а после конкретного существующего элемента (по его id)
•	Удаление — это логическая пометка, а не физическое удаление (tombstone)
Вот пример	
```js
class RGAElement {
  constructor(id, value, deleted = false) {
    this.id = id; // уникальный id (например, [время, id пользователя])
    this.value = value;
    this.deleted = deleted;
    this.next = [];
  }
}

class RGA {
  constructor() {
    this.elements = {}; // id -> RGAElement
    this.head = new RGAElement('head', null);
    this.elements['head'] = this.head;
  }

  insert(afterId, id, value) {
    const elem = new RGAElement(id, value);
    this.elements[id] = elem;
    this.elements[afterId].next.push(id);
  }

  delete(id) {
    if (this.elements[id]) {
      this.elements[id].deleted = true;
    }
  }

  // обход для получения текста
  toText() {
    const traverse = (id) => {
      let res = '';
      for (const nextId of this.elements[id].next) {
        if (!this.elements[nextId].deleted) {
          res += this.elements[nextId].value;
        }
        res += traverse(nextId);
      }
      return res;
    };
    return traverse('head');
  }
  merge(externalRGA: RGA) {
    for (const externalId in externalRGA.elements) {
      if (!this.elements[externalId]) {
        const externalElem = externalRGA.elements[externalId];
        // Вставляем отсутствующий элемент
		const elem = new RGAElement(externalElem.id, externalElem.value);
	    this.elements[externalElem.id] = elem;
        // Обновляем статус удаления
        if (externalElem.deleted) {
          this.delete(externalId);
        }
      }
    }
    
    // Обновляем связи next с сортировкой по ID
    for (const id in this.elements) {
      const elem = this.elements[id];
      elem.next = [...new Set([...elem.next, ...(externalRGA.elements[id]?.next || [])])]
        .sort((a, b) => a < b ? -1 : a > b ? 1 : 0 );
    }
  }
}
```

После выполнения операции слияния (merge) каждый массив `next` всегда будет отсортирован в одном и том же порядке. Это гарантирует то, что мы заранее знаем, в какую ветку графа необходимо спуститься первой. 
Получение текста из такой структуры можно представить как классический обход графа в глубину (DFS), с тем отличием, что порядок обхода ветвей заранее определён благодаря сортировке.
Рассмотрим пример: изначально в структуре хранится слово «привет». Затем три пользователя добавили свои ветки: «мир», «Вася» и «пока». После этого кто-то добавил «!» после «мир» и «река» после «пока». В результате, в массиве `next` у буквы «т» из слова «привет» появляется три элемента. При обходе графа мы следуем порядку, установленному на этапе слияния.
Таким образом, при восстановлении текста мы получим следующую последовательность:
«привет мир ! Вася пока река»
![[Снимок экрана 2025-06-17 в 14.03.34.png]]
Стоит отметить что в реальных реализациях CRDT, таких как Yjs, обычно используется усовершенствованная версия алгоритма RGA. Эти реализации включают несколько ключевых оптимизаций:
	•	Сокращение размера структур данных за счёт эффективного кодирования операций
	•	Механизмы сборки мусора для автоматического удаления элементов, помеченных как удалённые
	•	Улучшения производительности через оптимизацию сетевого взаимодействия и обработки конфликтов
Для определения порядка вставки элементов в распределённых системах обычно вместо id применяются логические метки времени, такие как Lamport Timestamps. Этот алгоритм обеспечивает частичное упорядочивание событий через поддержку счётчиков, синхронизируемых между узлами.

**4. Yjs: как устроено совместное редактирование на практике**
- Основные структуры данных Yjs (shared types: текст, массивы, карты)[2][4][5]
- Как Yjs реализует RGA/YATA и чем отличается от других CRDT[2][4]
- Кратко о производительности и оптимизациях Yjs (например, слияние структур, сборка мусора)[2][4]

**5. Пример: как выглядит код на Yjs**
- Минимальный пример создания документа, вставки, синхронизации
- Как легко интегрировать Yjs в свой проект

**6. Почему это не так сложно, как кажется**
- Сравнение с другими подходами (OT)
- Какие задачи Yjs решает «из коробки»
- Мифы о сложности CRDT и реальность

**Заключение**
- Куда копать дальше: ссылки на документацию, демо, обсуждения
- Призыв попробовать Yjs в своём проекте

---

**Примечание:**  
План выстроен от простого к сложному, с акцентом на практику и снятие страха перед CRDT и Yjs.

[^1]: 
